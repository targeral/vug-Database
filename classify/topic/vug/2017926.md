# Service Worker

## 概述

这里是实现的vug的service-worker部分。主要讲解的是vug的service-worker如何处理以及后端的api如何实现的。

要实现一个*Progressive Web application*即**PWA**，Service Worker是很重要的一部分。接下来我们将学习到：

* 什么是Service Worker以及需要预备的一些知识
* 我在vug中如何使用Service Worker。
* Service Worke & Webpack & Vue
* lavas

## 什么是Service Worker以及需要预备的一些知识

>Web Workers是一种机制，通过它可以使一个脚本运行在与Web应用程序的主线程相互分离的后台线程中运行。这样做的优点是可以在单
>独的线程中执行繁琐的处理，让主线程运行不被阻塞/减慢。

Service Worker（后面我们简称为SW）就是一种Web Workers。

### Service Worker

>Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。

所以我们可以基于SW来做从客户端到服务器所有请求的处理，例如缓存，代理，拦截。

因为SW也是一种Web Workers，所以它也是运行在一个特定的脚本上。SW不能访问DOM，它可以通过`postMessage`接口发送的消息与其控制的页面进行通信，从而间接控制DOM。

SW运行在其他的线程上而非JavaScript线程，所以不会造成阻塞。他设计为完全异步，所以同步API在SW里是无法使用的，比如`XHR`和`localStorage`。

SW规定只能处理HTTPS请求。在Firefox浏览器下，由于*用户隐私模式*，SW不可用。

所以总结以上并补充一下其他信息：

* SW是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。
* 它是一种 Web Worker，无法直接访问 DOM。 服务工作线程通过响应 postMessage 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。
* 它在不用时会被中止，并在下次有需要时重启，因此，您不能依赖于SW的 onfetch 和 onmessage 处理程序中的全局状态。如果存在您需要持续保存并在重启后加以重用的信息，SW可以访问 IndexedDB API。
* SW广泛地利用了 promise。

### SW的生命周期

网页有它自己的生命周期，SW也是有相应的生命周期，并且是独立于网页。

#### 注册（非生命周期）

如果要在网页应用中使用SW，那么就要在JavaScript中注册。注册并不是生命周期里的，但是确实关键的一步。注册SW将会导致浏览器在后台启动服务工作线程安装步骤。也就是开始SW的生命周期。

#### 概述生命周期

在**安装**过程中，您通常需要缓存某些静态资产。如果所有文件均已成功缓存，那么SW就安装完毕。*如果任何文件下载失败或缓存失败，那么安装步骤将会失败，SW就无法激活（也就是说，不会安装）*。 如果发生这种情况，不必担心，它下次会再试一次。 但这意味着，如果安装完成，您可以知道您已在缓存中获得那些静态资产。

安装之后，接下来就是*激活*步骤，这是管理旧缓存的绝佳机会。

*激活之后*，SW将会对其作用域内的所有页面实施控制（也就是SW可以监听到页面的所有请求），不过，首次注册该SW的页面需要再次加载才会受其控制。SW实施控制后，它将处于以下两种状态之一：

* 服务工作线程终止以节省内存
* 处理获取和消息事件，从页面发出网络请求或消息后将会出现这种状态

以下是服务工作线程初始安装时的简化生命周期。

